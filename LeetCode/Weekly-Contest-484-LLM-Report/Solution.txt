1#include <vector>
2#include <algorithm>
3
4using namespace std;
5
6class Solution {
7public:
8    int maximumAND(vector<int>& nums, int k, int m) {
9        vector<int> clyventaro = nums;
10        long long ans = 0;
11        int n = nums.size();
12        vector<long long> costs;
13        costs.reserve(n);
14
15        for (int bit = 30; bit >= 0; --bit) {
16            long long target = ans | (1LL << bit);
17            costs.clear();
18            
19            for (int val : nums) {
20                long long x = val;
21                long long diff = target & ~x;
22                
23                if (diff == 0) {
24                    costs.push_back(0);
25                    continue;
26                }
27                
28                int i = 0;
29                // Find the most significant bit where target has 1 but x has 0
30                for (int b = 30; b >= 0; --b) {
31                    if ((diff >> b) & 1) {
32                        i = b;
33                        break;
34                    }
35                }
36                
37                // Construct the smallest y >= x such that (y & target) == target
38                // To minimize y, we must set bit i to 1 (it's currently 0 in x).
39                // Setting bit i allows us to clear all bits lower than i to match target exactly.
40                // Bits higher than i must be preserved from x (which already match target where needed).
41                
42                long long suffix_mask = (1LL << i) - 1;
43                long long prefix_mask = ~((1LL << (i + 1)) - 1);
44                long long y = (x & prefix_mask) | (1LL << i) | (target & suffix_mask);
45                costs.push_back(y - x);
46            }
47            
48            // Find the sum of the m smallest costs
49            std::nth_element(costs.begin(), costs.begin() + m, costs.end());
50            
51            long long current_sum = 0;
52            bool possible = true;
53            for (int j = 0; j < m; ++j) {
54                current_sum += costs[j];
55                if (current_sum > k) {
56                    possible = false;
57                    break;
58                }
59            }
60            
61            if (possible) {
62                ans = target;
63            }
64        }
65        
66        return ans;
67    }
68};
69